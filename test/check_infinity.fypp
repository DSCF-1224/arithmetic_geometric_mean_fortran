#:include '../src/common.fypp'
#:set PROGRAM_NAME = 'check_infinity'
program ${PROGRAM_NAME}$

#:for REAL_KIND in REAL_KINDS
    use, intrinsic :: iso_fortran_env, only: ${REAL_KIND}$
#:endfor

    use, non_intrinsic :: arithmetic_geometric_mean_fortran

    use, non_intrinsic :: ieee_class_fortran



    implicit none



#:for REAL_KIND in REAL_KINDS
    call test_${REAL_KIND}$
#:endfor



    contains
#:for REAL_KIND in REAL_KINDS



    #:set SUBROUTINE_NAME = 'test_kernel_' + REAL_KIND
    subroutine ${SUBROUTINE_NAME}$(x, inf)

        real(${REAL_KIND}$), intent(in) :: x, inf



        real(${REAL_KIND}$) :: agm

        type(arithmetic_geometric_mean_${REAL_KIND}$_type) :: list



        agm = arithmetic_geometric_mean(x, inf)

        if ( .not. is_ieee_positive_inf(agm) ) error stop

        agm = arithmetic_geometric_mean(inf, x)

        if ( .not. is_ieee_positive_inf(agm) ) error stop



        call list%compute(x, inf)

        if ( .not. is_ieee_positive_inf( max(list) ) ) error stop

        call list%compute(inf, x)

        if ( .not. is_ieee_positive_inf( max(list) ) ) error stop

    end subroutine ${SUBROUTINE_NAME}$
    #:del SUBROUTINE_NAME



    #:set SUBROUTINE_NAME = 'test_' + REAL_KIND
    subroutine ${SUBROUTINE_NAME}$

        real(${REAL_KIND}$) :: agm, x, y

        type(arithmetic_geometric_mean_${REAL_KIND}$_type) :: list



        call set_ieee_positive_inf(y)



        call test_kernel_${REAL_KIND}$( x = tiny(x), inf = y )

        call test_kernel_${REAL_KIND}$( x = epsilon(x), inf = y )

        call test_kernel_${REAL_KIND}$( x = 1.0_${REAL_KIND}$, inf = y )

        call test_kernel_${REAL_KIND}$( x = huge(x), inf = y )



        call set_ieee_positive_inf(x)



        agm = arithmetic_geometric_mean(x, y)

        if ( .not. is_ieee_positive_inf(agm) ) error stop

        call list%compute(x, y)

        if ( .not. is_ieee_positive_inf( max(list) ) ) error stop

    end subroutine ${SUBROUTINE_NAME}$
    #:del SUBROUTINE_NAME
#:endfor

end program ${PROGRAM_NAME}$
