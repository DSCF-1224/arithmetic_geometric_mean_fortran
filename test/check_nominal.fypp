#:include '../src/common.fypp'
#:set PROGRAM_NAME   = 'check_nominal'
#:set MODULE_NAME    = PROGRAM_NAME + '_lib'
#:set INTERFACE_NAME = PROGRAM_NAME + '_kernel'
module ${MODULE_NAME}$

    use, intrinsic :: iso_fortran_env, only: error_unit
#:for REAL_KIND in REAL_KINDS
    use, intrinsic :: iso_fortran_env, only: ${REAL_KIND}$
#:endfor

    use, intrinsic :: ieee_arithmetic, only: ieee_is_normal
    use, intrinsic :: ieee_arithmetic, only: ieee_next_after
    use, intrinsic :: ieee_arithmetic, only: ieee_value

    use, non_intrinsic :: arithmetic_geometric_mean_fortran



    implicit none



    private

    public :: ${INTERFACE_NAME}$



    interface ${INTERFACE_NAME}$
    #:for REAL_KIND in REAL_KINDS
        module procedure :: ${INTERFACE_NAME}$_${REAL_KIND}$
    #:endfor
    end interface ${INTERFACE_NAME}$



    interface ${INTERFACE_NAME}$_half
    #:for REAL_KIND in REAL_KINDS
        module procedure :: ${INTERFACE_NAME}$_half_${REAL_KIND}$
    #:endfor
    end interface ${INTERFACE_NAME}$_half



    contains
#:for REAL_KIND in REAL_KINDS



    #:set SUBROUTINE_NAME = INTERFACE_NAME + '_' + REAL_KIND
    subroutine ${SUBROUTINE_NAME}$(x, y)

        real(${REAL_KIND}$), intent(in) :: x, y



        call ${INTERFACE_NAME}$_half(x, y)
        call ${INTERFACE_NAME}$_half(y, x)

    end subroutine ${SUBROUTINE_NAME}$
    #:del SUBROUTINE_NAME



    #:set SUBROUTINE_NAME = INTERFACE_NAME + '_half_' + REAL_KIND
    subroutine ${SUBROUTINE_NAME}$(x, y)

        real(${REAL_KIND}$), intent(in) :: x, y



        real(${REAL_KIND}$) :: agm

        type(arithmetic_geometric_mean_${REAL_KIND}$_type) :: list



        agm = arithmetic_geometric_mean(x, y)

        if ( .not. ieee_is_normal(agm) ) error stop



        call list%compute(x, y)

    #:for MAX_OR_MIN in MAX_AND_MIN
        if ( .not. ieee_is_normal( ${MAX_OR_MIN}$(list) ) ) error stop
    #:endfor
    #:del MAX_OR_MIN

        if ( ${N_ITER}$(list) .lt. 1 ) error stop

    end subroutine ${SUBROUTINE_NAME}$
    #:del SUBROUTINE_NAME
#:endfor

end module ${MODULE_NAME}$



program ${PROGRAM_NAME}$

#:for REAL_KIND in REAL_KINDS
    use, intrinsic :: iso_fortran_env, only: ${REAL_KIND}$
#:endfor

    use, intrinsic :: ieee_arithmetic, only: ieee_next_after

    use, non_intrinsic :: ${MODULE_NAME}$



    implicit none



#:for REAL_KIND in REAL_KINDS
    call test_${REAL_KIND}$
#:endfor



    contains
#:for REAL_KIND in REAL_KINDS



    #:set SUBROUTINE_NAME = 'test_' + REAL_KIND
    subroutine ${SUBROUTINE_NAME}$

        real(${REAL_KIND}$) :: x, y



        x = 1.0_${REAL_KIND}$

        y = tiny(y)

        call ${INTERFACE_NAME}$(x, y)



        y = epsilon(y)

        call ${INTERFACE_NAME}$(x, y)



        x   = sqrt( huge(x) )
        y   = ieee_next_after(x, 0.0_${REAL_KIND}$)

        call ${INTERFACE_NAME}$(x, y)

    end subroutine ${SUBROUTINE_NAME}$
    #:del SUBROUTINE_NAME
#:endfor

end program ${PROGRAM_NAME}$
