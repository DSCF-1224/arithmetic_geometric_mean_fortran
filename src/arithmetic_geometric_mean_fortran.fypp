#:include 'common.fypp'
#:set INTERFACE_NAME_KERNEL = 'arithmetic_geometric_mean'
module arithmetic_geometric_mean_fortran
#:include 'module_description.fypp'

#:for REAL_KIND in REAL_KINDS
    use, intrinsic :: iso_fortran_env, only: ${REAL_KIND}$
#:endfor

    use, intrinsic :: ieee_arithmetic, only: ieee_quiet_nan
    use, intrinsic :: ieee_arithmetic, only: ieee_unordered
    use, intrinsic :: ieee_arithmetic, only: ieee_value



    implicit none



    private

    public :: ${INTERFACE_NAME_KERNEL}$
    public :: ${INTERFACE_NAME_KERNEL}$_kernel

#:for REAL_KIND in REAL_KINDS
    public :: ${INTERFACE_NAME_KERNEL}$_${REAL_KIND}$_type
#:endfor



    integer, parameter :: initial_n_iter = -1



    interface ${INTERFACE_NAME_KERNEL}$
        #:include 'arithmetic_geometric_mean_description.fypp'

    #:for REAL_KIND in REAL_KINDS
        module procedure :: ${INTERFACE_NAME_KERNEL}$_${REAL_KIND}$
    #:endfor

    end interface ${INTERFACE_NAME_KERNEL}$



#:set INTERFACE_NAME = INTERFACE_NAME_KERNEL + '_kernel'
    interface ${INTERFACE_NAME}$
        #:include 'arithmetic_geometric_mean_kernel_description.fypp'

    #:for REAL_KIND in REAL_KINDS
        module procedure :: ${INTERFACE_NAME}$_${REAL_KIND}$
    #:endfor

    end interface ${INTERFACE_NAME}$
#:del INTERFACE_NAME



    #:set TYPE_NAME = INTERFACE_NAME_KERNEL + '_base_type'
    type, abstract :: ${TYPE_NAME}$

        integer, private :: n_iter = initial_n_iter
        !! the number of iterations performed during AGM calculation

    end type ${TYPE_NAME}$
    #:del TYPE_NAME
#:for REAL_KIND in REAL_KINDS



    #:set TYPE_NAME = INTERFACE_NAME_KERNEL + '_' + REAL_KIND + '_type'
    type, extends(${INTERFACE_NAME_KERNEL}$_base_type) :: ${TYPE_NAME}$
    end type ${TYPE_NAME}$
    #:del TYPE_NAME
#:endfor



    contains
#:for REAL_KIND in REAL_KINDS



    #:set FUNCTION_NAME = INTERFACE_NAME_KERNEL + '_' + REAL_KIND
    elemental function ${FUNCTION_NAME}$(x, y) result(agm)
        #:include 'arithmetic_geometric_mean_description.fypp'

        real(${REAL_KIND}$), intent(in) :: x, y



        real(${REAL_KIND}$) :: agm ! return value



        real(${REAL_KIND}$) :: xy !! x * y



        if ( ieee_unordered(x, y) ) then

            agm = ieee_value(agm, ieee_quiet_nan); return

        end if



        xy = x * y



        if ( xy .lt. 0.0_${REAL_KIND}$ ) then

            agm = ieee_value(agm, ieee_quiet_nan)

        else if ( xy .gt. 0.0_${REAL_KIND}$ ) then

            if (x .lt. y) then
                agm = arithmetic_geometric_mean_kernel( a = y, g = x )
            else
                agm = arithmetic_geometric_mean_kernel( a = x, g = y )
            end if

        else

            agm = 0.0_${REAL_KIND}$

        end if

    end function ${FUNCTION_NAME}$
    #:del FUNCTION_NAME
#:endfor
#:for REAL_KIND in REAL_KINDS
    #:set FUNCTION_NAME = INTERFACE_NAME_KERNEL + '_kernel_' + REAL_KIND



    elemental function ${FUNCTION_NAME}$(a, g) result(agm)
        #:include 'arithmetic_geometric_mean_kernel_description.fypp'

        real(${REAL_KIND}$), intent(in) :: a !! arithmetic mean

        real(${REAL_KIND}$), intent(in) :: g !! geometric mean



        real(${REAL_KIND}$) :: agm ! return value



        real(${REAL_KIND}$) :: last_a !! last arithmetic mean

        real(${REAL_KIND}$) :: last_g !! last geometric mean

        real(${REAL_KIND}$) :: next_a !! next arithmetic mean

        real(${REAL_KIND}$) :: next_g !! next geometric mean



        last_a = a
        last_g = g



        do

            next_a =     (last_a + last_g) * 0.5_${REAL_KIND}$
            next_g = sqrt(last_a * last_g)

            if ( abs(next_a - next_g) .gt. spacing( min(next_a, next_g) ) ) then

                last_a = next_a
                last_g = next_g

                cycle

            else

                agm = max(next_a, next_g)

                return

            end if

        end do

    end function ${FUNCTION_NAME}$
    #:del FUNCTION_NAME
#:endfor

end module arithmetic_geometric_mean_fortran
